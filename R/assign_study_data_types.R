#' Summarize data types for the study
#'
#' Data types are summarized, or "rolled-up", for the study based on its child file annotations.
#' Summary values are added back and overwrites the current `dataType` annotation for the study.
#' See also `update_study_annotations`, where study-level annotations are *rolled down* to child files.
#'
#' @param study_table_id Synapse ID of the portal study table/view that lists relevant studies in column `id` or `studyId`.
#' @param fileview_id Synapse ID of the portal fileview.
#' @param id_col Name of the id column in `study_table_id` and `fileview_id`.
#' @param attribute The attribute that we are summarizing from `fileview_id`; name should not contain spaces. Defaults to `dataType`.
#' @param dry_run Default = TRUE. Whether to update as well or just return list of annotation objects.
#' @return List of annotations objects.
#' @examples
#' \dontrun{
#' assign_study_data_types(study_table_id = 'syn52694652',
#'                         fileview_id = 'syn16858331',
#'                         id_col = 'studyId',
#'                         id_col = 'studyId',
#'                         dry_run = T)
#'}
#' @export
assign_study_data_types <- function(study_table_id,
                                    fileview_id,
                                    id_col = "studyId",
                                    attribute = "dataType",
                                    dry_run = TRUE) {

  .check_login()

  # get studies from study table
  studies <- table_query(table_id = study_table_id, columns = id_col) %>% unlist()

  # query the fileview
  fv <- .syn$tableQuery(
    glue::glue("select {id_col},group_concat(distinct {attribute}) as {attribute} from {fileview_id} where type = \'file\' and {attribute} is not null and {id_col} is not null group by {id_col}"),
    includeRowIdAndRowVersion = F)$asDataFrame()
  meta <- lapply(fv[[attribute]], function(x) unique(trimws(strsplit(x, split = ",")[[1]]))) # stray whitespaces still occasional issue
  names(meta) <- fv[[id_col]]

  result_list <- list()
  for(study in names(meta)) {
    study_meta <- .syn$get_annotations(study)
    study_meta[attribute] <- meta[[study]]
    result_list[[study]] <- study_meta
    if(!dry_run) {
      # Also submit study_meta conditional on hard-coded check / roll-ups should not really exceed 50 values
      if(length(meta[[study]] > 50)) {
        warning(glue::glue("There are over 50 values. Since this exceeds typical length limits and might indicate data issues, skipping update for {study}."))
      } else {
        .syn$set_annotations(study_meta)
        message(glue::glue("Updated {study} {attribute} summary"))
      }
    }
  }

  invisible(result_list)
}

#' Retrieve valid subclasses of a value in a JSON-LD schema
#' @description Retrieve valid subclasses of a value in a JSON-LD schema generated by schematic.
#' @param schema_url Default: the NF-OSI JSON-LD schema.
#' @param parent_name Default = DataType. The value for which you'd like to find the associated subclasses.
#' @param parent_context Default = bts. The JSON-LD context for the value in question.
#' @return A character vector of values.
#' @export
get_valid_values_from_json_schema <- function(schema_url = 'https://raw.githubusercontent.com/nf-osi/nf-metadata-dictionary/main/NF.jsonld',
                                              parent_name = 'DataType',
                                              parent_context = 'bts'){

  parent_id <- paste0(parent_context, ':', parent_name)

  subclasses <-
    jsonlite::fromJSON(schema_url) %>%
    purrr::pluck("@graph") %>%
    dplyr::filter(purrr::map_lgl(`rdfs:subClassOf`, ~ parent_id %in% .x)) %>%
    dplyr::pull(`sms:displayName`)

  subclasses
}
